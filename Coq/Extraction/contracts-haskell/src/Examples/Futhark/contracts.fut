let env1 : []f64 = [5000.0, 5400.0, 5200.0, 5900.0, 5100.0, 3100.0, 5210.0]
let env2 : []f64 = [4010.0, 2400.0, 4200.0, 4900.0, 4100.0, 4100.0, 4210.0]
let env3 : []f64 = map (\_ -> 5000.0) (0...366)
let disc : []f64 = [1.0, 0.99, 0.98, 0.96, 0.94, 0.9, 0.85]
let disc1 :[]f64 = disc ++ (map (\_ -> 0.8) (0...500))

-- ifWithin(obs(l,0) > strike, n, scale(obs(l,0)-strike, transfer(p1,p2,EUR)), zero)
-- loopif(model(l,0)>strike,n, (model(l,0)-strike) * disc(0), 0.0)
-- this is just a direct translation written by hand to sketch an implementation of "loopif"
let cont(strike: f64, n: i32, env : []f64): f64 =
  -- first, we scan the environment to find the index where the condition holds
  let ind = (loop i = 0 while (!(env[i] > strike)&&(i < n)) do i+1)
  in
  -- now we check if condition is true for the position we have found
  if (env[ind] > strike) then
     (env[ind] - strike) * 10.0
  else 0.0

-- code for the simple barrer contract generated by the payoffs-to-futhark pretty-printer.
-- tenv[0] is a maturity parameter
-- t_now represents the cut-payoff time: now payoff before t_now will be considered
let payoffInternal(ext : []f64, tenv : []i32, disc : []f64, t0 : i32, t_now : i32): f64 =
  let t0 = (loop t0 = t0 while (!((((ext[0 + 0+ t0])) <= (4000.0))))&&(t0 < (tenv[0])) do t0+1) in
  if (((ext[0 + 0+ t0])) <= (4000.0)) then (0.0) else (((2000.0) * ((if ((((0) + t0) < (t_now))) then (0.0)else (disc[0+ t0])))))

let payoff(ext : []f64, tenv : []i32, disc : []f64, t_now : i32): f64 = payoffInternal(ext, tenv, disc, 0, t_now)

let main = payoff(env1,[4],disc1,0)