
==================== FINAL INTERFACE ====================
2018-04-08 09:58:10.788907 UTC

interface main@main:Contract 7103
  interface hash: 355e12158ee7180ac175680cd83163a9
  ABI hash: a001d2d1dcba9b7dbff93220b44302c9
  export-list hash: 03296e9aefab777c45a744199fc35678
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e08a1e695a3d5701efe398d91e65cc68
  sig of: Nothing
  used TH splices: False
  where
exports:
  Contract.acc_sem
  Contract.add_time
  Contract.adv_ext
  Contract.compare1
  Contract.elimVarC
  Contract.elimVarE
  Contract.elimVarV
  Contract.empty
  Contract.fromBLit
  Contract.fromLit
  Contract.fromRLit
  Contract.getFMap
  Contract.has_type
  Contract.horizon
  Contract.iadd
  Contract.ileb
  Contract.imin
  Contract.inferC
  Contract.inferE
  Contract.inferObs
  Contract.inferOp
  Contract.inst_contr
  Contract.isOneLit
  Contract.isZeroLit
  Contract.is_empty
  Contract.lookupEnv
  Contract.lookupEnvP
  Contract.map
  Contract.opSem
  Contract.plus0
  Contract.redfun
  Contract.scale_trans'
  Contract.singleton
  Contract.singleton0
  Contract.smartBoth
  Contract.smartLet
  Contract.smartScale
  Contract.smartTranslate
  Contract.specialise
  Contract.specialiseExp
  Contract.specialiseFun
  Contract.specialiseOp
  Contract.specialiseOpSimp
  Contract.sub_time
  Contract.tadd
  Contract.tadd'
  Contract.texprSem
  Contract.tileb
  Contract.time
  Contract.tleb
  Contract.tmax
  Contract.tmaxs
  Contract.toLit
  Contract.translateExp
  Contract.traverseIf
  Contract.tsub
  Contract.tsub'
  Contract.tyeqb
  Contract.type0
  Contract.unionWith
  Contract.union_with
  BaseTypes.Asset{BaseTypes.CHF BaseTypes.DKK BaseTypes.EUR BaseTypes.JPY BaseTypes.USD}
  BaseTypes.BoolObs{BaseTypes.Decision BaseTypes.Default}
  BaseTypes.Party{BaseTypes.P1 BaseTypes.P2 BaseTypes.P3 BaseTypes.X BaseTypes.Y BaseTypes.Z}
  BaseTypes.RealObs{BaseTypes.Clock BaseTypes.FX BaseTypes.Stock}
  BaseTypes.TVar
  Contract.Contr{Contract.Both Contract.If Contract.Let Contract.Scale Contract.Transfer Contract.Translate Contract.Zero}
  Contract.Env'
  Contract.EnvP
  Contract.Exp{Contract.Acc Contract.Obs Contract.OpE Contract.VarE}
  Contract.ExtEnv'
  Contract.ExtEnvP
  Contract.FMap
  Contract.Key
  Contract.List
  Contract.ObsLabel{Contract.LabB Contract.LabR}
  Contract.Op{Contract.Add Contract.And Contract.BLit Contract.Cond Contract.Div Contract.Equal Contract.Leq Contract.Less Contract.Mult Contract.Neg Contract.Not Contract.Or Contract.RLit Contract.Sub}
  Contract.SMap
  Contract.TEnv
  Contract.TExpr{Contract.Tnum Contract.Tvar}
  Contract.TiTy{Contract.TimedType}
  Contract.TiTyEnv
  Contract.TimeB{Contract.Time Contract.TimeBot}
  Contract.TimeI{Contract.Time' Contract.TimeTop}
  Contract.Ty{Contract.BOOL Contract.REAL}
  Contract.Val{Contract.BVal Contract.RVal}
  Contract.Var{Contract.V1 Contract.VS}
module dependencies: BaseTypes
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.Traversable 7576318f4ef8587ad947f87012b65abf
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map 1800ccac43fd924c376b60eac12f4d04
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base 642e37808d03e24efbe8e8ff1336f343
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  BaseTypes 65c5f953f1981ab087685c5da86fba76
  exports: 23778ad265b8e00b4976c7375a9c4325
  Asset cb66f9f4d11d7a383a10bbc8a156e568
  BoolObs dae79b8c6797ec9ef37d391a1e745c55
  CHF b307b8be91a336f44368e185f5cac541
  Clock 9b975b3621618abbdc70ef014c2e6a4c
  DKK 704943acbdd4ca583eab9a9df637dffb
  Decision a5d5909fcd5fd9ed49d3a280eadec207
  Default 27ea4e91b7f2a85c7c1e49aa8518371f
  EUR f5e7aafdef4ba43fb11832949e03491f
  FX ff896b187dafc0596774425edbf8c85a
  JPY 997c40e7f627a86681775c517dd2e4b4
  P1 b85d5e84981f7c1f627dfc545fde4a8f
  P2 57925e8bcc2206627a0593b1fe017236
  P3 6dc88e13aa0aeb7703c9da742c38b859
  Party dfcc89f4500c3c01e7f357657e35e437
  RealObs 7ca671cc5c62c89221d4c2a2ec67ae6e
  Stock 072d1222ca60b7277ef5aee0921b438d
  TVar d45411a9ca27f2054bce703984df44fb
  USD 423d75c170ae52515d504bd068003b8f
  X d0fa2e26fd9bb1d70762cd30ecc77def
  Y d2b554c47d69c971910282357174aac8
  Z b4c4164fcd5d277fa37a83a8c34cb6b8
ad37bc055277a8286f993e034490ddee
  $sfilterGt1 ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) v
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) v
  {- Arity: 2, Strictness: <L,1*U(U(U,U),U)><S,1*U> -}
dafbc826ac7ac7a15ce4efa4a14867d5
  $sfilterLt1 ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) v
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) v
  {- Arity: 2, Strictness: <L,1*U(U(U,U),U)><S,1*U> -}
d0e09c98904bd2348e0ac161d4da6b9b
  $sinsert_$sgo10 ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> a1
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1
  {- Arity: 3, Strictness: <S,1*U(U(U,U),U)><L,U><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   w :: ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                   w1 :: a1
                   w2 :: Data.Map.Base.Map
                           ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1 ->
                 case w of ww { (,) ww1 ww2 ->
                 Contract.$w$sgo10 @ a1 ww1 ww2 w1 w2 }) -}
97bdd01afdb5c0be0c5ef3048d156d33
  $smergeWithKey2 ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U(U,U),U)><L,1*U(U(U,U),U)><S,1*U> -}
ccc7d8b68cc42bd10134f66485d4b38b
  $smergeWithKey4 ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U(U,U),U)><S,1*U> -}
d9530d194e4c683100d4e1f75110cf68
  $w$sgo10 ::
    (BaseTypes.Party, BaseTypes.Party)
    -> BaseTypes.Asset
    -> a1
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1
  {- Arity: 4, Strictness: <L,U(U,U)><L,U><L,U><S,1*U>,
     Inline: [0] -}
c53b01400d0d9819e28f1aeda3fbef6c
  $w$sgreater ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1
    -> (# GHC.Base.Maybe a1,
          Data.Map.Base.Map
            ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1 #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U(U,U),U)><S,1*U>,
     Inline: [0] -}
3bdbcbc1e24a1cb9bcb7bb4cc5e6c397
  $w$smiddle ::
    ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1
    -> (# GHC.Base.Maybe a1,
          Data.Map.Base.Map
            ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a1 #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U(U,U),U)><L,1*U(U(U,U),U)><S,1*U>,
     Inline: [0] -}
e632aa4676645c36cef6bf4d937f3a1a
  $wacc_sem ::
    (GHC.Types.Int -> a1 -> a1) -> GHC.Prim.Int# -> a1 -> a1
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,U><L,1*U>,
     Inline: [0] -}
d08f4576eac0ef4f67f3393b5a770151
  $whorizon :: Contract.Contr -> Contract.TEnv -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,C(U(U))>,
     Inline: [0] -}
8db7cc3d98f3b2b57a94ab1dc38f8d02
  $wpoly_go10 ::
    (BaseTypes.Party, BaseTypes.Party)
    -> BaseTypes.Asset
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U,U)><L,U><S,1*U>,
     Inline: [0] -}
960cda48296766c0091ee527d100d08f
  $wsingleton0 ::
    BaseTypes.Party
    -> BaseTypes.Party
    -> BaseTypes.Asset
    -> GHC.Prim.Double#
    -> Contract.SMap
  {- Arity: 4, Strictness: <B,U><B,U><B,U><B,U>b, Inline: [0] -}
2b7cf2ff7abe4fab650faa1cd601f781
  data Contr
    = Zero
    | Let Contract.Exp Contract.Contr
    | Transfer BaseTypes.Party BaseTypes.Party BaseTypes.Asset
    | Scale Contract.Exp Contract.Contr
    | Translate Contract.TExpr Contract.Contr
    | Both Contract.Contr Contract.Contr
    | If Contract.Exp Contract.TExpr Contract.Contr Contract.Contr
f40eda0c688bf21ccf9fd5fb36d6eaee
  type Env' a = Contract.List a
26d02324faf11d8f1eb786e273dfc522
  type EnvP = Contract.List (GHC.Base.Maybe Contract.Val)
b1478d2a0af0ab23b8b9450d84006b6a
  data Exp
    = OpE Contract.Op (Contract.List Contract.Exp)
    | Obs Contract.ObsLabel GHC.Types.Int
    | VarE Contract.Var
    | Acc Contract.Exp GHC.Types.Int Contract.Exp
2c36c4e4f545acd3b3bc6b9a472e6dee
  type ExtEnv' a = Contract.ObsLabel -> GHC.Types.Int -> a
a0cff53ce1a33876a957716e00d9398b
  type ExtEnvP = Contract.ExtEnv' (GHC.Base.Maybe Contract.Val)
6e856864eb0603bd83f936fe4b42c773
  type FMap =
    Data.Map.Base.Map
      ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
      GHC.Types.Double
816e1f7f05760e89673edc0c0d31f5ac
  type Key = ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
1653b7a867990c5735f986807402466e
  type List a = [a]
9eaec7e0150a3d9437c71b1eb0741d47
  data ObsLabel = LabR BaseTypes.RealObs | LabB BaseTypes.BoolObs
8b9a75298b057e373283c5fd1bb10843
  data Op
    = Add
    | Sub
    | Mult
    | Div
    | And
    | Or
    | Less
    | Leq
    | Equal
    | Not
    | Neg
    | BLit GHC.Types.Bool
    | RLit GHC.Types.Double
    | Cond
8969ff47fd922bdc64c131070961e7fb
  type SMap = Contract.FMap
3dee5a45696566dd6f9150b11ca801da
  type TEnv = BaseTypes.TVar -> GHC.Types.Int
b6d3d122a20c7bad1349187712a593b3
  data TExpr = Tvar BaseTypes.TVar | Tnum GHC.Types.Int
42d7977c2b2eae5516cfa061fc4e7805
  data TiTy = TimedType Contract.Ty Contract.TimeB
93ddfda704ab9f7039ee3288818f83cf
  type TiTyEnv = Contract.Env' Contract.TiTy
d119a3784b9fe1b2341845cf1ed23943
  data TimeB = Time GHC.Types.Int | TimeBot
c676ca7679143f87e9cf409f519086c0
  data TimeI = Time' Contract.TimeB | TimeTop
b7248e282b8d1d9e9e95a82775257d08
  data Ty = REAL | BOOL
    Promotable
a65e4f73859840c0849db6d6dc7522c1
  data Val = BVal GHC.Types.Bool | RVal GHC.Types.Double
36f582ab9bdb8a4fafb1f7c30a86d949
  data Var = V1 | VS Contract.Var
    Promotable
a28cf8fc6a0e6594faf6fc10a83a1f58
  acc_sem :: (GHC.Types.Int -> a1 -> a1) -> GHC.Types.Int -> a1 -> a1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S(S),1*U(U)><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   w :: GHC.Types.Int -> a1 -> a1
                   w1 :: GHC.Types.Int
                   w2 :: a1 ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Contract.$wacc_sem @ a1 w ww1 w2 }) -}
aae03cebfb694c0f37f19ab5af596798
  add_time :: GHC.Types.Int -> Contract.TiTy -> Contract.TiTy
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int t :: Contract.TiTy ->
                 case t of wild { Contract.TimedType ty ti ->
                 Contract.TimedType ty (Contract.tadd' d ti) }) -}
6c23d3f1ae202f3a150b1730813c7492
  adv_ext ::
    GHC.Types.Int -> Contract.ExtEnv' a1 -> Contract.ExtEnv' a1
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(U)><C(C(S)),1*C1(C1(U))><L,U><L,1*U(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a1
                   d :: GHC.Types.Int
                   e :: Contract.ExtEnv' a1
                   l :: Contract.ObsLabel
                   x :: GHC.Types.Int ->
                 e l (GHC.Num.$fNumInt_$c+ d x)) -}
321590a4ef60d77b8e96422104d1d91b
  compare1 ::
    BaseTypes.Party -> BaseTypes.Party -> GHC.Types.Ordering
  {- Strictness: b -}
69a312cf79f284d94a4972dcf8c2c548
  elimVarC ::
    Contract.Var -> Contract.Contr -> GHC.Base.Maybe Contract.Contr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
06fd5b401472a8b8712ef134d410f241
  elimVarE ::
    Contract.Var -> Contract.Exp -> GHC.Base.Maybe Contract.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
ea14ff4f886e1ef221bc3f2b894f2f4e
  elimVarV ::
    Contract.Var -> Contract.Var -> GHC.Base.Maybe Contract.Var
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e5527d87efd8bf753a18bd0ac3de8410
  empty :: Contract.SMap
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (Data.Map.Base.Tip
                   @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                   @ GHC.Types.Double) -}
bf4a6d6ca4072f4fdf6b9b4102f07c5c
  fromBLit :: Contract.Exp -> GHC.Base.Maybe GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ e :: Contract.Exp ->
                 case e of wild {
                   DEFAULT -> GHC.Base.Nothing @ GHC.Types.Bool
                   Contract.OpE op args
                   -> case op of wild1 {
                        DEFAULT -> GHC.Base.Nothing @ GHC.Types.Bool
                        Contract.BLit b
                        -> case args of wild2 {
                             [] -> GHC.Base.Just @ GHC.Types.Bool b
                             : ds ds1 -> GHC.Base.Nothing @ GHC.Types.Bool } } }) -}
2a2306f463c73ed00ce5ede80e08bebd
  fromLit :: Contract.Exp -> GHC.Base.Maybe Contract.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ e :: Contract.Exp ->
                 case e of wild {
                   DEFAULT -> GHC.Base.Nothing @ Contract.Val
                   Contract.OpE op args
                   -> case op of wild1 {
                        DEFAULT -> GHC.Base.Nothing @ Contract.Val
                        Contract.BLit b
                        -> case args of wild2 {
                             [] -> GHC.Base.Just @ Contract.Val (Contract.BVal b)
                             : ds ds1 -> GHC.Base.Nothing @ Contract.Val }
                        Contract.RLit r
                        -> case args of wild2 {
                             [] -> GHC.Base.Just @ Contract.Val (Contract.RVal r)
                             : ds ds1 -> GHC.Base.Nothing @ Contract.Val } } }) -}
5ec1fe65e9a81f9f21ddbc1f184c04a8
  fromRLit :: Contract.Exp -> GHC.Base.Maybe GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ e :: Contract.Exp ->
                 case e of wild {
                   DEFAULT -> GHC.Base.Nothing @ GHC.Types.Double
                   Contract.OpE op args
                   -> case op of wild1 {
                        DEFAULT -> GHC.Base.Nothing @ GHC.Types.Double
                        Contract.RLit r
                        -> case args of wild2 {
                             [] -> GHC.Base.Just @ GHC.Types.Double r
                             : ds ds1 -> GHC.Base.Nothing @ GHC.Types.Double } } }) -}
fab79d0f6546a0b6a9cc283816cdb445
  getFMap :: Contract.SMap -> Contract.FMap
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ sm :: Contract.SMap -> sm) -}
ef88103c1053336a3094e5ac841be041
  has_type :: Contract.TEnv -> Contract.Contr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ tenv :: Contract.TEnv c :: Contract.Contr ->
                 case Contract.inferC
                        (GHC.Types.[] @ Contract.TiTy)
                        tenv
                        c of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just ds -> GHC.Types.True }) -}
259357ef4ac5cbf3ff7140ae6a97f5ef
  horizon :: Contract.Contr -> Contract.TEnv -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,C(U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Contract.Contr w1 :: Contract.TEnv ->
                 case Contract.$whorizon w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
5a4cf9977159ec3db1d025c33c5f0287
  iadd :: GHC.Types.Int -> Contract.TimeI -> Contract.TimeI
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int t :: Contract.TimeI ->
                 case t of wild {
                   Contract.Time' t' -> Contract.Time' (Contract.tadd' d t')
                   Contract.TimeTop -> Contract.TimeTop }) -}
61a131efe00d08650504a21ce4d77462
  ileb :: Contract.TimeI -> Contract.TimeI -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ t1 :: Contract.TimeI t2 :: Contract.TimeI ->
                 case t1 of wild {
                   Contract.Time' s1
                   -> case t2 of wild1 {
                        Contract.Time' s2 -> Contract.tleb s1 s2
                        Contract.TimeTop -> GHC.Types.True }
                   Contract.TimeTop
                   -> case t2 of wild1 {
                        Contract.Time' ds -> GHC.Types.False
                        Contract.TimeTop -> GHC.Types.True } }) -}
861c2b4b1545be1cd8254f690f374df6
  imin :: Contract.TimeI -> Contract.TimeI -> Contract.TimeI
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ t1 :: Contract.TimeI t2 :: Contract.TimeI ->
                 case t1 of wild {
                   Contract.Time' s1
                   -> case t2 of wild1 {
                        Contract.Time' s2
                        -> case s1 of wild2 {
                             Contract.Time t1'
                             -> case s2 of wild3 {
                                  Contract.Time t2'
                                  -> case t1' of wild4 { GHC.Types.I# x ->
                                     case t2' of wild5 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<=# x y) of wild6 {
                                       GHC.Types.False -> wild1 GHC.Types.True -> wild } } }
                                  Contract.TimeBot -> wild1 }
                             Contract.TimeBot -> wild }
                        Contract.TimeTop -> wild }
                   Contract.TimeTop -> t2 }) -}
2f7b7dae597576e52de7fc06637c3069
  inferC ::
    Contract.TiTyEnv
    -> Contract.TEnv -> Contract.Contr -> GHC.Base.Maybe Contract.TimeI
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(U(U))><S,1*U> -}
117ee847a3a666e7344df151636f8d36
  inferE ::
    Contract.TiTyEnv -> Contract.Exp -> GHC.Base.Maybe Contract.TiTy
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
8493d47d8f591792853071b0eb8223f1
  inferObs :: Contract.ObsLabel -> Contract.Ty
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ l :: Contract.ObsLabel ->
                 case l of wild {
                   Contract.LabR ds -> Contract.REAL
                   Contract.LabB ds -> Contract.BOOL }) -}
4798b3a43ade4b966c856581a887f5d3
  inferOp ::
    Contract.Op
    -> Contract.List Contract.Ty -> GHC.Base.Maybe Contract.Ty
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ op :: Contract.Op
                   args :: Contract.List Contract.Ty ->
                 case op of wild {
                   DEFAULT
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t0 l0
                                  -> case t0 of wild4 {
                                       Contract.REAL
                                       -> case l0 of wild5 {
                                            [] -> Contract.inferOp2
                                            : ds ds1 -> GHC.Base.Nothing @ Contract.Ty }
                                       Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                             Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                   Contract.And
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL -> GHC.Base.Nothing @ Contract.Ty
                             Contract.BOOL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t0 l0
                                  -> case t0 of wild4 {
                                       Contract.REAL -> GHC.Base.Nothing @ Contract.Ty
                                       Contract.BOOL
                                       -> case l0 of wild5 {
                                            [] -> Contract.inferOp1
                                            : ds ds1 -> GHC.Base.Nothing @ Contract.Ty } } } } }
                   Contract.Or
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL -> GHC.Base.Nothing @ Contract.Ty
                             Contract.BOOL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t0 l0
                                  -> case t0 of wild4 {
                                       Contract.REAL -> GHC.Base.Nothing @ Contract.Ty
                                       Contract.BOOL
                                       -> case l0 of wild5 {
                                            [] -> Contract.inferOp1
                                            : ds ds1 -> GHC.Base.Nothing @ Contract.Ty } } } } }
                   Contract.Less
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t0 l0
                                  -> case t0 of wild4 {
                                       Contract.REAL
                                       -> case l0 of wild5 {
                                            [] -> Contract.inferOp1
                                            : ds ds1 -> GHC.Base.Nothing @ Contract.Ty }
                                       Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                             Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                   Contract.Leq
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t0 l0
                                  -> case t0 of wild4 {
                                       Contract.REAL
                                       -> case l0 of wild5 {
                                            [] -> Contract.inferOp1
                                            : ds ds1 -> GHC.Base.Nothing @ Contract.Ty }
                                       Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                             Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                   Contract.Equal
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t0 l0
                                  -> case t0 of wild4 {
                                       Contract.REAL
                                       -> case l0 of wild5 {
                                            [] -> Contract.inferOp1
                                            : ds ds1 -> GHC.Base.Nothing @ Contract.Ty }
                                       Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                             Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                   Contract.Not
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL -> GHC.Base.Nothing @ Contract.Ty
                             Contract.BOOL
                             -> case l of wild3 {
                                  [] -> Contract.inferOp1
                                  : ds ds1 -> GHC.Base.Nothing @ Contract.Ty } } }
                   Contract.Neg
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL
                             -> case l of wild3 {
                                  [] -> Contract.inferOp2
                                  : ds ds1 -> GHC.Base.Nothing @ Contract.Ty }
                             Contract.BOOL -> GHC.Base.Nothing @ Contract.Ty } }
                   Contract.BLit ds
                   -> case args of wild1 {
                        [] -> Contract.inferOp1
                        : ds1 ds2 -> GHC.Base.Nothing @ Contract.Ty }
                   Contract.RLit ds
                   -> case args of wild1 {
                        [] -> Contract.inferOp2
                        : ds1 ds2 -> GHC.Base.Nothing @ Contract.Ty }
                   Contract.Cond
                   -> case args of wild1 {
                        [] -> GHC.Base.Nothing @ Contract.Ty
                        : t l
                        -> case t of wild2 {
                             Contract.REAL -> GHC.Base.Nothing @ Contract.Ty
                             Contract.BOOL
                             -> case l of wild3 {
                                  [] -> GHC.Base.Nothing @ Contract.Ty
                                  : t1 l0
                                  -> case l0 of wild4 {
                                       [] -> GHC.Base.Nothing @ Contract.Ty
                                       : t2 l1
                                       -> case l1 of wild5 {
                                            []
                                            -> case t1 of wild6 {
                                                 Contract.REAL
                                                 -> case t2 of wild7 {
                                                      Contract.REAL -> Contract.inferOp2
                                                      Contract.BOOL
                                                      -> GHC.Base.Nothing @ Contract.Ty }
                                                 Contract.BOOL
                                                 -> case t2 of wild7 {
                                                      Contract.REAL
                                                      -> GHC.Base.Nothing @ Contract.Ty
                                                      Contract.BOOL -> Contract.inferOp1 } }
                                            : ds ds1
                                            -> GHC.Base.Nothing @ Contract.Ty } } } } } }) -}
488a8e74d6c108b17f0f083ef04bda4a
  inferOp1 :: GHC.Base.Maybe Contract.Ty
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Contract.Ty Contract.BOOL) -}
cdcdf54eff9e8b054d8396d47759fd69
  inferOp2 :: GHC.Base.Maybe Contract.Ty
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Contract.Ty Contract.REAL) -}
26aef873924008e0acee222e79957826
  inst_contr :: Contract.Contr -> Contract.TEnv -> Contract.Contr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,C(U(U))> -}
a3278c666aeb00315e529b2541f7ccd9
  isOneLit :: Contract.Exp -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ e :: Contract.Exp ->
                 case e of wild {
                   DEFAULT -> GHC.Types.False
                   Contract.OpE op args
                   -> case op of wild1 {
                        DEFAULT -> GHC.Types.False
                        Contract.RLit r
                        -> case args of wild2 {
                             []
                             -> case r of wild3 { GHC.Types.D# x ->
                                GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==## x 1.0) }
                             : ds ds1 -> GHC.Types.False } } }) -}
55605064ff1a47095b47b1542425e7a3
  isZeroLit :: Contract.Exp -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ e :: Contract.Exp ->
                 case e of wild {
                   DEFAULT -> GHC.Types.False
                   Contract.OpE op args
                   -> case op of wild1 {
                        DEFAULT -> GHC.Types.False
                        Contract.RLit r
                        -> case args of wild2 {
                             []
                             -> case r of wild3 { GHC.Types.D# x ->
                                GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==## x 0.0) }
                             : ds ds1 -> GHC.Types.False } } }) -}
b4ecf9bdf4c97922802a3c2808adc49d
  is_empty :: Contract.SMap -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ sm :: Contract.SMap ->
                 case sm of wild {
                   Data.Map.Base.Bin dt ds1 ds2 ds3 ds4 -> GHC.Types.False
                   Data.Map.Base.Tip -> GHC.Types.True }) -}
ca4134467f42edfb6a8eec847b6a1ed5
  lookupEnv :: Contract.Var -> Contract.Env' a1 -> GHC.Base.Maybe a1
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
bd06c6d43c4c37e7de40d8cb922cf144
  lookupEnvP ::
    Contract.Var -> Contract.EnvP -> GHC.Base.Maybe Contract.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
88321abfd1eca8fa714e19de8f7955fc
  map ::
    (GHC.Types.Double -> GHC.Types.Double)
    -> Contract.SMap -> Contract.SMap
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (Data.Map.Base.map
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)) -}
6ee1e056e2fee5cd3e24b750f0056860
  opSem ::
    Contract.Op
    -> Contract.List Contract.Val -> GHC.Base.Maybe Contract.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
761eadf7134704549f680a40c32de3fb
  plus0 :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ n :: GHC.Types.Int m :: GHC.Types.Int ->
                 case m of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT
                   -> case n of wild2 { GHC.Types.I# x1 ->
                      GHC.Types.I# (GHC.Prim.+# x1 wild1) }
                   0 -> Contract.plus1 } }) -}
4931f4fa270426276f23e782864f9e96
  plus1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
f230b4423d5106edce535450ff15064f
  redfun ::
    Contract.Contr
    -> Contract.EnvP
    -> Contract.ExtEnvP
    -> Contract.TEnv
    -> GHC.Base.Maybe (Contract.Contr, Contract.SMap)
  {- Arity: 4, Strictness: <S,1*U><L,U><L,C(C1(U))><L,C(U(1*U))> -}
80590405a00b17b0cd2d192cf37d1f8c
  scale_trans' ::
    GHC.Base.Maybe GHC.Types.Double
    -> Contract.SMap -> GHC.Base.Maybe Contract.SMap
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ v :: GHC.Base.Maybe GHC.Types.Double
                   t :: Contract.SMap ->
                 case v of wild {
                   GHC.Base.Nothing
                   -> case t of wild1 {
                        Data.Map.Base.Bin dt ds1 ds2 ds3 ds4
                        -> GHC.Base.Nothing @ Contract.SMap
                        Data.Map.Base.Tip -> Contract.scale_trans'1 }
                   GHC.Base.Just v0
                   -> GHC.Base.Just
                        @ Contract.SMap
                        (case v0 of wild1 { GHC.Types.D# x ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.==## x 0.0) of wild2 {
                           GHC.Types.False
                           -> Data.Map.Base.map
                                @ GHC.Types.Double
                                @ GHC.Types.Double
                                @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                                (\ x1 :: GHC.Types.Double ->
                                 case x1 of wild3 { GHC.Types.D# y ->
                                 GHC.Types.D# (GHC.Prim.*## x y) })
                                t
                           GHC.Types.True
                           -> Data.Map.Base.Tip
                                @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                                @ GHC.Types.Double } }) }) -}
2f47a9163e38fa1487b320ad563bb0cd
  scale_trans'1 :: GHC.Base.Maybe Contract.SMap
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ Contract.SMap
                   (Data.Map.Base.Tip
                      @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                      @ GHC.Types.Double)) -}
7f24ea679306cc7ca2ec976f787cb069
  singleton :: Contract.Key -> GHC.Types.Double -> Contract.FMap
  {- Arity: 2, Strictness: <S,1*U(U(U,U),U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ k :: Contract.Key r :: GHC.Types.Double ->
                 Contract.$sinsert_$sgo10
                   @ GHC.Types.Double
                   k
                   r
                   (Data.Map.Base.Tip
                      @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                      @ GHC.Types.Double)) -}
ed3e15896f3574df42028e33dffe0949
  singleton0 ::
    BaseTypes.Party
    -> BaseTypes.Party
    -> BaseTypes.Asset
    -> GHC.Types.Double
    -> Contract.SMap
  {- Arity: 4, Strictness: <B,U><B,U><B,U><B,U(U)>b,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: BaseTypes.Party
                   w1 :: BaseTypes.Party
                   w2 :: BaseTypes.Asset
                   w3 :: GHC.Types.Double ->
                 case w3 of ww { GHC.Types.D# ww1 ->
                 Contract.$wsingleton0 w w1 w2 ww1 }) -}
974ec0cf28a3c3d487c90840c60c8457
  smartBoth :: Contract.Contr -> Contract.Contr -> Contract.Contr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ c1 :: Contract.Contr c2 :: Contract.Contr ->
                 case c1 of wild {
                   DEFAULT
                   -> case c2 of wild1 {
                        DEFAULT -> Contract.Both wild wild1 Contract.Zero -> wild }
                   Contract.Zero -> c2 }) -}
11388ef3427b6619c3fdea96d4407511
  smartLet :: Contract.Exp -> Contract.Contr -> Contract.Contr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ e :: Contract.Exp c :: Contract.Contr ->
                 case Contract.elimVarC Contract.V1 c of wild {
                   GHC.Base.Nothing -> Contract.Let e c GHC.Base.Just c' -> c' }) -}
8d5c597a9e03d6a185a7ad96cf81919a
  smartScale :: Contract.Exp -> Contract.Contr -> Contract.Contr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ e :: Contract.Exp c :: Contract.Contr ->
                 case e of wild {
                   DEFAULT
                   -> case c of wild1 {
                        DEFAULT -> Contract.Scale wild wild1
                        Contract.Zero -> Contract.Zero }
                   Contract.OpE op args
                   -> case op of wild1 {
                        DEFAULT
                        -> case c of wild2 {
                             DEFAULT -> Contract.Scale wild wild2
                             Contract.Zero -> Contract.Zero }
                        Contract.RLit r
                        -> case args of wild2 {
                             []
                             -> case r of wild3 { GHC.Types.D# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==## x 0.0) of wild4 {
                                  GHC.Types.False
                                  -> case c of wild5 {
                                       DEFAULT -> Contract.Scale wild wild5
                                       Contract.Zero -> Contract.Zero }
                                  GHC.Types.True -> Contract.Zero } }
                             : ds ds1
                             -> case c of wild3 {
                                  DEFAULT -> Contract.Scale wild wild3
                                  Contract.Zero -> Contract.Zero } } } }) -}
1c0a4914c1ccb49a5484c75c8f87b899
  smartTranslate :: GHC.Types.Int -> Contract.Contr -> Contract.Contr
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ l :: GHC.Types.Int c :: Contract.Contr ->
                 case l of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT
                   -> case c of wild2 {
                        DEFAULT -> Contract.Translate (Contract.Tnum wild) wild2
                        Contract.Zero -> Contract.Zero }
                   0 -> c } }) -}
3046e53ec955bc9d32f1789b347896cc
  specialise ::
    Contract.Contr
    -> Contract.EnvP
    -> Contract.TEnv
    -> Contract.ExtEnvP
    -> Contract.Contr
  {- Arity: 4, Strictness: <S,1*U><L,U><L,C(U(U))><L,U> -}
dbbca8d10693ba7affac72bcbee714a7
  specialiseExp ::
    Contract.Exp -> Contract.EnvP -> Contract.ExtEnvP -> Contract.Exp
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,C(C1(U))> -}
04e97971bcce4dc492de6cf40ff0c9a2
  specialiseFun ::
    (Contract.List (GHC.Base.Maybe Contract.Val)
     -> Contract.ExtEnv' (GHC.Base.Maybe Contract.Val) -> Contract.Exp)
    -> Contract.EnvP
    -> Contract.ExtEnvP
    -> GHC.Types.Int
    -> GHC.Base.Maybe Contract.Val
    -> GHC.Base.Maybe Contract.Val
  {- Arity: 5, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,C(C1(U))><L,U(U)><L,U>,
     Unfolding: (\ f :: Contract.List (GHC.Base.Maybe Contract.Val)
                        -> Contract.ExtEnv' (GHC.Base.Maybe Contract.Val) -> Contract.Exp
                   env :: Contract.EnvP
                   ext :: Contract.ExtEnvP
                   l :: GHC.Types.Int
                   r :: GHC.Base.Maybe Contract.Val ->
                 Contract.fromLit
                   (f (GHC.Types.: @ (GHC.Base.Maybe Contract.Val) r env)
                      (\ l1 :: Contract.ObsLabel x :: GHC.Types.Int ->
                       ext l1 (GHC.Num.$fNumInt_$c+ l x)))) -}
e5672c3cbf767dcd2ea0152fc7965fbf
  specialiseOp ::
    Contract.Op
    -> Contract.List Contract.Exp -> GHC.Base.Maybe Contract.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
3aa84fc5a4befd97b018fc6a644f2315
  specialiseOpSimp ::
    Contract.Op
    -> Contract.List Contract.Exp -> GHC.Base.Maybe Contract.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ op :: Contract.Op
                   args :: Contract.List Contract.Exp ->
                 case Contract.specialiseOpSimp_go args of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ Contract.Exp
                   GHC.Base.Just x
                   -> case Contract.opSem op x of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ Contract.Exp
                        GHC.Base.Just a1
                        -> GHC.Base.Just @ Contract.Exp (Contract.toLit a1) } }) -}
cb6665eaf74920be9681d9769186868d
  specialiseOpSimp_go ::
    [Contract.Exp] -> GHC.Base.Maybe [Contract.Val]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6b9c13b7fe43030ad7b7a2e392f8d83b
  sub_time :: GHC.Types.Int -> Contract.TiTy -> Contract.TiTy
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int t :: Contract.TiTy ->
                 case t of wild { Contract.TimedType ty ti ->
                 Contract.TimedType ty (Contract.tsub' d ti) }) -}
fa71beeb711cf206cbf076800a9bf24e
  tadd :: GHC.Types.Int -> Contract.TimeB -> Contract.TimeB
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int t :: Contract.TimeB ->
                 case t of wild {
                   Contract.Time t' -> Contract.Time (GHC.Num.$fNumInt_$c+ t' d)
                   Contract.TimeBot -> Contract.TimeBot }) -}
4f230f79d06a4a1b62abe5f230919e7f
  tadd' :: GHC.Types.Int -> Contract.TimeB -> Contract.TimeB
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int t :: Contract.TimeB ->
                 case t of wild {
                   Contract.Time t' -> Contract.Time (GHC.Num.$fNumInt_$c+ t' d)
                   Contract.TimeBot -> Contract.TimeBot }) -}
69ad79423cc0d41cb2415ac062ae29e2
  texprSem :: Contract.TExpr -> Contract.TEnv -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ e :: Contract.TExpr tenv :: Contract.TEnv ->
                 case e of wild {
                   Contract.Tvar v -> tenv v Contract.Tnum n -> n }) -}
3b35e9b4bc46736fd3b9e93e6d6d508b
  tileb :: Contract.TimeB -> Contract.TimeI -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ l :: Contract.TimeB t :: Contract.TimeI ->
                 case t of wild {
                   Contract.Time' t' -> Contract.tleb l t'
                   Contract.TimeTop -> GHC.Types.True }) -}
706bb00c8e5f21cc93d38494a7405ece
  time :: Contract.TiTy -> Contract.TimeB
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ t :: Contract.TiTy ->
                 case t of wild { Contract.TimedType ds ti -> ti }) -}
93d071db949f61e95985ec6c0e95115a
  tleb :: Contract.TimeB -> Contract.TimeB -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ t1 :: Contract.TimeB t2 :: Contract.TimeB ->
                 case t1 of wild {
                   Contract.Time t1'
                   -> case t2 of wild1 {
                        Contract.Time t2' -> GHC.Classes.leInt t1' t2'
                        Contract.TimeBot -> GHC.Types.False }
                   Contract.TimeBot -> GHC.Types.True }) -}
791c613514fdba1e7298c546f3e47749
  tmax :: Contract.TimeB -> Contract.TimeB -> Contract.TimeB
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ t1 :: Contract.TimeB t2 :: Contract.TimeB ->
                 case t1 of wild {
                   Contract.Time t1'
                   -> case t2 of wild1 {
                        Contract.Time t2'
                        -> Contract.Time (GHC.Classes.$fOrdInt_$cmax t1' t2')
                        Contract.TimeBot -> wild }
                   Contract.TimeBot -> t2 }) -}
a896fa6fa35dd5f2d7097ff771b1a48e
  tmaxs :: Contract.List Contract.TimeB -> Contract.TimeB
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ ts :: Contract.List Contract.TimeB ->
                 Contract.tmaxs_go ts) -}
5e41d5225b4edfe907111ca145375c13
  tmaxs_go :: [Contract.TimeB] -> Contract.TimeB
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
34416d433cb26519b8e736b5afc604bc
  toLit :: Contract.Val -> Contract.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m1,
     Unfolding: InlineRule (1, True, False)
                (\ e :: Contract.Val ->
                 case e of wild {
                   Contract.BVal b
                   -> Contract.OpE (Contract.BLit b) (GHC.Types.[] @ Contract.Exp)
                   Contract.RVal r
                   -> Contract.OpE
                        (Contract.RLit r)
                        (GHC.Types.[] @ Contract.Exp) }) -}
ca6071733a03c7874ea1c8cb9d953ead
  translateExp :: GHC.Types.Int -> Contract.Exp -> Contract.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U> -}
ac3f1792d7be719f9bf9f53297003ebc
  traverseIf ::
    Contract.EnvP
    -> Contract.ExtEnvP
    -> Contract.Exp
    -> (Contract.ExtEnvP -> Contract.Contr)
    -> (Contract.ExtEnvP -> Contract.Contr)
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.Maybe Contract.Contr
  {- Arity: 7,
     Strictness: <L,U><L,U><S,U><L,1*C1(U)><L,1*C1(U)><L,1*U(U)><L,1*U(1*U)> -}
dc9eaa1295d8771f9f7024ad3cc956aa
  tsub :: GHC.Types.Int -> Contract.TimeB -> Contract.TimeB
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int eta :: Contract.TimeB ->
                 case eta of wild {
                   Contract.Time t'
                   -> Contract.Time
                        (case t' of wild1 { GHC.Types.I# x ->
                         case d of wild2 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.+# x (GHC.Prim.negateInt# x1)) } })
                   Contract.TimeBot -> Contract.TimeBot }) -}
8cead81e2ba06c8ce2e555e70f3bef65
  tsub' :: GHC.Types.Int -> Contract.TimeB -> Contract.TimeB
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ d :: GHC.Types.Int eta :: Contract.TimeB ->
                 case eta of wild {
                   Contract.Time t'
                   -> Contract.Time
                        (case t' of wild1 { GHC.Types.I# x ->
                         case d of wild2 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.+# x (GHC.Prim.negateInt# x1)) } })
                   Contract.TimeBot -> Contract.TimeBot }) -}
4fb8ff1d9ff93ed5133c60aa1196f4f7
  tyeqb :: Contract.Ty -> Contract.Ty -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ t1 :: Contract.Ty t2 :: Contract.Ty ->
                 case t1 of wild {
                   Contract.REAL
                   -> case t2 of wild1 {
                        Contract.REAL -> GHC.Types.True Contract.BOOL -> GHC.Types.False }
                   Contract.BOOL
                   -> case t2 of wild1 {
                        Contract.REAL -> GHC.Types.False
                        Contract.BOOL -> GHC.Types.True } }) -}
34efc9146a0076c922407be5f9629618
  type0 :: Contract.TiTy -> Contract.Ty
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ t :: Contract.TiTy ->
                 case t of wild { Contract.TimedType ty ds -> ty }) -}
36aecbe1077cfdb912570c55c2d6171d
  unionWith ::
    GHC.Classes.Ord k =>
    (a -> a -> GHC.Base.Maybe a)
    -> Data.Map.Base.Map k a
    -> Data.Map.Base.Map k a
    -> Data.Map.Base.Map k a
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),C(C1(U)),C(C1(U)),A,C(C1(U)),A,A)><L,C(C1(U))><S,1*U><S,1*U> -}
e416360912c963a291d02a34d6c2c82d
  unionWith_$sunionWith ::
    (a -> a -> GHC.Base.Maybe a)
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
    -> Data.Map.Base.Map
         ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset) a
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U> -}
ada69f31fb28540a2128fad7f81d6726
  union_with ::
    (GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Double)
    -> Contract.SMap -> Contract.SMap -> Contract.SMap
  {- Arity: 3, Strictness: <L,C(C1(U(U)))><S,1*U><S,1*U>,
     Unfolding: (\ f :: GHC.Types.Double
                        -> GHC.Types.Double -> GHC.Types.Double
                   sm1 :: Contract.SMap
                   sm2 :: Contract.SMap ->
                 Contract.unionWith_$sunionWith
                   @ GHC.Types.Double
                   (\ x :: GHC.Types.Double y :: GHC.Types.Double[OneShot] ->
                    case f x y of wild { GHC.Types.D# x1 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.==## x1 0.0) of wild1 {
                      GHC.Types.False -> GHC.Base.Just @ GHC.Types.Double wild
                      GHC.Types.True -> GHC.Base.Nothing @ GHC.Types.Double } })
                   sm1
                   sm2) -}
"SPEC unionWith _ @ ((Party, Party), Asset)" [ALWAYS] forall @ a
                                                             $dOrd :: GHC.Classes.Ord
                                                                        ((BaseTypes.Party,
                                                                          BaseTypes.Party),
                                                                         BaseTypes.Asset)
  Contract.unionWith @ a
                     @ ((BaseTypes.Party, BaseTypes.Party), BaseTypes.Asset)
                     $dOrd
  = Contract.unionWith_$sunionWith @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

