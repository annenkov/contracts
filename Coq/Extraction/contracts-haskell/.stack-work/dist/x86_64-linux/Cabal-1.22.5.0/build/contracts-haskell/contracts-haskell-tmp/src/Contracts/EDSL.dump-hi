
==================== FINAL INTERFACE ====================
2018-04-08 09:58:11.819958 UTC

interface main@main:EDSL 7103
  interface hash: 120825c05e5d558ac14c2dbc44f8f789
  ABI hash: eb30536764a08a94649694935286a5a9
  export-list hash: 76b05b5ed21f7c54f0406700965e5762
  orphan hash: c71b6089f2175cdaa1cb4b4fe6ecc966
  flag hash: 45f449a2b69f99294a25e93f4d1244b3
  sig of: Nothing
  used TH splices: False
  where
exports:
  EDSL.advance
  EDSL.hasType
  EDSL.horizon
  EDSL.mkExtEnvP
  EDSL.printContr
  EDSL.showContr
  EDSL.specialise
  HOAS.!
  HOAS.!&!
  HOAS.!/=!
  HOAS.!<!
  HOAS.!<=!
  HOAS.!=!
  HOAS.!>!
  HOAS.!>=!
  HOAS.!|!
  HOAS.#
  HOAS.&
  HOAS.bNot
  HOAS.bObs
  HOAS.false
  HOAS.iff
  HOAS.rLit
  HOAS.rObs
  HOAS.true
  BaseTypes.Asset{BaseTypes.CHF BaseTypes.DKK BaseTypes.EUR BaseTypes.JPY BaseTypes.USD}
  BaseTypes.BoolObs{BaseTypes.Decision BaseTypes.Default}
  BaseTypes.Party{BaseTypes.P1 BaseTypes.P2 BaseTypes.P3 BaseTypes.X BaseTypes.Y BaseTypes.Z}
  BaseTypes.RealObs{BaseTypes.Clock BaseTypes.FX BaseTypes.Stock}
  BaseTypes.TVar
  Contract.ExtEnvP
  Contract.FMap
  Contract.ObsLabel{Contract.LabB Contract.LabR}
  Contract.TExpr
  HOAS.B
  HOAS.BExp
  HOAS.Contr
  HOAS.ContrHoas{HOAS.both HOAS.ifWithin HOAS.ifWithinT HOAS.letc HOAS.scale HOAS.transfer HOAS.translate HOAS.translateT HOAS.zero}
  HOAS.Exp
  HOAS.ExpHoas
  HOAS.ExpHoas'|{HOAS.acc HOAS.ife}
  HOAS.R
  HOAS.RExp
module dependencies: BaseTypes Contract HOAS PrettyPrinting
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         main@main:HOAS main@main:PrettyPrinting
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0248c1e850b7ea124cf7a2e1669ebf67
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map 1800ccac43fd924c376b60eac12f4d04
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base 642e37808d03e24efbe8e8ff1336f343
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  BaseTypes 65c5f953f1981ab087685c5da86fba76
  Asset cb66f9f4d11d7a383a10bbc8a156e568
  BoolObs dae79b8c6797ec9ef37d391a1e745c55
  CHF b307b8be91a336f44368e185f5cac541
  Clock 9b975b3621618abbdc70ef014c2e6a4c
  DKK 704943acbdd4ca583eab9a9df637dffb
  Decision a5d5909fcd5fd9ed49d3a280eadec207
  Default 27ea4e91b7f2a85c7c1e49aa8518371f
  EUR f5e7aafdef4ba43fb11832949e03491f
  FX ff896b187dafc0596774425edbf8c85a
  JPY 997c40e7f627a86681775c517dd2e4b4
  P1 b85d5e84981f7c1f627dfc545fde4a8f
  P2 57925e8bcc2206627a0593b1fe017236
  P3 6dc88e13aa0aeb7703c9da742c38b859
  Party dfcc89f4500c3c01e7f357657e35e437
  RealObs 7ca671cc5c62c89221d4c2a2ec67ae6e
  Stock 072d1222ca60b7277ef5aee0921b438d
  TVar d45411a9ca27f2054bce703984df44fb
  USD 423d75c170ae52515d504bd068003b8f
  X d0fa2e26fd9bb1d70762cd30ecc77def
  Y d2b554c47d69c971910282357174aac8
  Z b4c4164fcd5d277fa37a83a8c34cb6b8
import  -/  Contract a001d2d1dcba9b7dbff93220b44302c9
  exports: 03296e9aefab777c45a744199fc35678
  BVal 223277297e85585ab21011c112c1ca11
  ExtEnvP a0cff53ce1a33876a957716e00d9398b
  FMap 6e856864eb0603bd83f936fe4b42c773
  LabB 8d7b6ec21f78a7809518abcda9224011
  LabR 7cb28ffb686b74dbb1694a608e78429e
  ObsLabel 9eaec7e0150a3d9437c71b1eb0741d47
  RVal 4e994d352147cec72cc40eef53e6a251
  TEnv 3dee5a45696566dd6f9150b11ca801da
  TExpr b6d3d122a20c7bad1349187712a593b3
  has_type ef88103c1053336a3094e5ac841be041
  horizon 259357ef4ac5cbf3ff7140ae6a97f5ef
  redfun f230b4423d5106edce535450ff15064f
  specialise 3046e53ec955bc9d32f1789b347896cc
import  -/  HOAS 30142d8132ad9fdb45a0c9d1ca0fdc65
  exports: 30836575c2ad86bf46bf191ea76e57ac
  ! d9840583a6ff9b5e2d7c0e4ab767dd22
  !&! 88bea997b59b08ae272a2f9dd43e698d
  !/=! 37965007e1d5bc601bd88a68ce018606
  !<! a852fea87142a06cb5b162136adf8fe5
  !<=! cdb72c1c6a861f17ae9bdf70ed0ee9aa
  !=! 93b48586259f43b1115bb7e39da46999
  !>! ac79c8ca209bb97c7c7bb543c99755a5
  !>=! cfde0927ad8a0d7968c133beb9be81b9
  !|! 6120d46e453f223c26cec00d0440c665
  # 3c9ad694a72b4837af3e4a766a2be99c
  & 38736f5544e5a01891f7467caa07da3e
  B b7009fef581143a0e28439b7ff2069dc
  BExp 320f98e163787e5ebe8eaace00550a27
  Contr 41b09272fc4d23d4addccdd83f150c68
  ContrHoas 70b39d36af0ed9c7fc3ff750be42ca48
  Exp 1ebe07472ebc532623f889fc374dcdee
  ExpHoas 8681f28c922d9f67b0f5084de64fbc99
  R ea70e4d138d72a601a60132767fc950b
  RExp 29079cf3ff64b0117289796aa6826fe2
  acc ba15c9837a4d4c135161254a794a4376
  bNot b5d8c994efa616eb237daee1f2f2e07b
  bObs efc2256f9dd82feb8906496e95f87ecb
  both 348ee766f3de36e743b1ae4390a198e3
  false 9da62d3c63c8195f2bb561209d99115f
  fromHoas 24c82b570e4ffd5b958cbfeaa2ce5e4f
  ifWithin d5302b53a7795afedfeea747a4c75e78
  ifWithinT 3bc5f3ac363360a8b850d9b59c5f5ddf
  ife b63dea38f3e14925003a2cdc283c16e8
  iff 3e8b17a3bae40e3308028390ad23b98f
  letc 857caed89d9c1baf4f03c1f3b939b16a
  rLit a986cc284bf875ba3593d179a97f78f4
  rObs 33ca9c674a79874ed3e3e422529c808a
  scale 0d3659bf4922f82de92e7bfd2b95b3ec
  toHoas 0badf4db4e662402d2d29dad7b3bebc6
  transfer 754343aba24b3e57921527c9140d584f
  translate 3455c1e457d6ab99cbc58f619f067d2b
  translateT b1bfd22cb2153a801bb82dad59459fef
  true a5c7fd19f1d915410c3aef0d439e5663
  zero f1220e1a462c5917830fd140860efa27
b730e6ad0ab1afb109d4a0646d4a146f
  $s$fEq(,) :: GHC.Classes.Eq (BaseTypes.BoolObs, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (BaseTypes.BoolObs, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     BaseTypes.$fEqBoolObs
                     GHC.Classes.$fEqInt)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     BaseTypes.$fEqBoolObs
                     GHC.Classes.$fEqInt) -}
2f34c8cd8da4e6245d9edb2328ae48ee
  $s$fEq(,)1 :: GHC.Classes.Eq (BaseTypes.RealObs, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (BaseTypes.RealObs, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     BaseTypes.$fEqRealObs
                     GHC.Classes.$fEqInt)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     BaseTypes.$fEqRealObs
                     GHC.Classes.$fEqInt) -}
12a004f815a1f18e166e4b298ce2c864
  $s$fOrd(,) :: GHC.Classes.Ord (BaseTypes.BoolObs, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (BaseTypes.BoolObs, GHC.Types.Int)
                  EDSL.$s$fOrd(,)1
                  (GHC.Classes.$fOrd(,)_$ccompare
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c<
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c<=
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c>
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c>=
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$cmax
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$cmin
                     @ BaseTypes.BoolObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)1
                     BaseTypes.$fOrdBoolObs
                     GHC.Classes.$fOrdInt) -}
34d72c43723a30ddf9eb4db2774004b8
  $s$fOrd(,)1 :: GHC.Classes.Eq (BaseTypes.BoolObs, GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) EDSL.$s$fEq(,) -}
0472acffc801c2746bec7be886d53994
  $s$fOrd(,)2 :: GHC.Classes.Ord (BaseTypes.RealObs, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (BaseTypes.RealObs, GHC.Types.Int)
                  EDSL.$s$fOrd(,)3
                  (GHC.Classes.$fOrd(,)_$ccompare
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c<
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c<=
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c>
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$c>=
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$cmax
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt)
                  (GHC.Classes.$fOrd(,)_$cmin
                     @ BaseTypes.RealObs
                     @ GHC.Types.Int
                     EDSL.$s$fOrd(,)3
                     BaseTypes.$fOrdRealObs
                     GHC.Classes.$fOrdInt) -}
b9ee0586390fa6a42d1a82bf3acf220c
  $s$fOrd(,)3 :: GHC.Classes.Eq (BaseTypes.RealObs, GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) EDSL.$s$fEq(,)1 -}
81580924a15f354e9055453d90eaccdc
  $sfromList ::
    [((BaseTypes.BoolObs, GHC.Types.Int), a)]
    -> Data.Map.Base.Map (BaseTypes.BoolObs, GHC.Types.Int) a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a
                   ds :: [((BaseTypes.BoolObs, GHC.Types.Int), a)] ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { (,) ipv ipv1 ->
                           Data.Map.Base.Bin
                             @ (BaseTypes.BoolObs, GHC.Types.Int)
                             @ a
                             1
                             dt
                             x
                             (Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a)
                             (Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case kx of ww { (,) ww1 ww2 ->
                           case ky of ww3 { (,) ww4 ww5 ->
                           case BaseTypes.$fOrdBoolObs_$ccompare ww1 ww4 of wild4 {
                             GHC.Types.LT
                             -> EDSL.$wpoly_go10
                                  @ a
                                  1
                                  (Data.Map.Base.Bin
                                     @ (BaseTypes.BoolObs, GHC.Types.Int)
                                     @ a
                                     1
                                     ww
                                     x
                                     (Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a)
                                     (Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a))
                                  wild2
                             GHC.Types.EQ
                             -> case ww2 of wild5 { GHC.Types.I# x1 ->
                                case ww5 of wild6 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.>=# x1 y) of wild7 {
                                  GHC.Types.False
                                  -> EDSL.$wpoly_go10
                                       @ a
                                       1
                                       (Data.Map.Base.Bin
                                          @ (BaseTypes.BoolObs, GHC.Types.Int)
                                          @ a
                                          1
                                          ww
                                          x
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.BoolObs, GHC.Types.Int)
                                             @ a)
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.BoolObs, GHC.Types.Int)
                                             @ a))
                                       wild2
                                  GHC.Types.True
                                  -> EDSL.$sfromList1
                                       @ a
                                       (Data.Map.Base.Bin
                                          @ (BaseTypes.BoolObs, GHC.Types.Int)
                                          @ a
                                          1
                                          ww
                                          x
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.BoolObs, GHC.Types.Int)
                                             @ a)
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.BoolObs, GHC.Types.Int)
                                             @ a))
                                       wild2 } } }
                             GHC.Types.GT
                             -> EDSL.$sfromList1
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ (BaseTypes.BoolObs, GHC.Types.Int)
                                     @ a
                                     1
                                     ww
                                     x
                                     (Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a)
                                     (Data.Map.Base.Tip @ (BaseTypes.BoolObs, GHC.Types.Int) @ a))
                                  wild2 } } } } } } }) -}
028360477228123c35416b187dc42b1d
  $sfromList1 ::
    Data.Map.Base.Map (BaseTypes.BoolObs, GHC.Types.Int) a1
    -> [((BaseTypes.BoolObs, GHC.Types.Int), a1)]
    -> Data.Map.Base.Map (BaseTypes.BoolObs, GHC.Types.Int) a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
bd278b04442e417dca939197f0b59561
  $sfromList2 ::
    [((BaseTypes.RealObs, GHC.Types.Int), a)]
    -> Data.Map.Base.Map (BaseTypes.RealObs, GHC.Types.Int) a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a
                   ds :: [((BaseTypes.RealObs, GHC.Types.Int), a)] ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { (,) ipv ipv1 ->
                           Data.Map.Base.Bin
                             @ (BaseTypes.RealObs, GHC.Types.Int)
                             @ a
                             1
                             dt
                             x
                             (Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a)
                             (Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case kx of ww { (,) ww1 ww2 ->
                           case ky of ww3 { (,) ww4 ww5 ->
                           case BaseTypes.$fOrdRealObs_$ccompare ww1 ww4 of wild4 {
                             GHC.Types.LT
                             -> EDSL.$wpoly_go1
                                  @ a
                                  1
                                  (Data.Map.Base.Bin
                                     @ (BaseTypes.RealObs, GHC.Types.Int)
                                     @ a
                                     1
                                     ww
                                     x
                                     (Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a)
                                     (Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a))
                                  wild2
                             GHC.Types.EQ
                             -> case ww2 of wild5 { GHC.Types.I# x1 ->
                                case ww5 of wild6 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.>=# x1 y) of wild7 {
                                  GHC.Types.False
                                  -> EDSL.$wpoly_go1
                                       @ a
                                       1
                                       (Data.Map.Base.Bin
                                          @ (BaseTypes.RealObs, GHC.Types.Int)
                                          @ a
                                          1
                                          ww
                                          x
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.RealObs, GHC.Types.Int)
                                             @ a)
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.RealObs, GHC.Types.Int)
                                             @ a))
                                       wild2
                                  GHC.Types.True
                                  -> EDSL.$sfromList3
                                       @ a
                                       (Data.Map.Base.Bin
                                          @ (BaseTypes.RealObs, GHC.Types.Int)
                                          @ a
                                          1
                                          ww
                                          x
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.RealObs, GHC.Types.Int)
                                             @ a)
                                          (Data.Map.Base.Tip
                                             @ (BaseTypes.RealObs, GHC.Types.Int)
                                             @ a))
                                       wild2 } } }
                             GHC.Types.GT
                             -> EDSL.$sfromList3
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ (BaseTypes.RealObs, GHC.Types.Int)
                                     @ a
                                     1
                                     ww
                                     x
                                     (Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a)
                                     (Data.Map.Base.Tip @ (BaseTypes.RealObs, GHC.Types.Int) @ a))
                                  wild2 } } } } } } }) -}
a29526766030c0628d2159ad2c9067ac
  $sfromList3 ::
    Data.Map.Base.Map (BaseTypes.RealObs, GHC.Types.Int) a1
    -> [((BaseTypes.RealObs, GHC.Types.Int), a1)]
    -> Data.Map.Base.Map (BaseTypes.RealObs, GHC.Types.Int) a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
f0b6cbc29f4b9fff8f2800e190fe8094
  $sinsert_go1 ::
    GHC.Classes.Ord k1 =>
    k1 -> a1 -> Data.Map.Base.Map k1 a1 -> Data.Map.Base.Map k1 a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U><S,1*U> -}
c44c4dfaeaa8215697909d9d838515c5
  $sinsert_go10 ::
    GHC.Classes.Ord k1 =>
    k1 -> a1 -> Data.Map.Base.Map k1 a1 -> Data.Map.Base.Map k1 a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U><S,1*U> -}
a4e6883a1c92363003648d97ee19f11a
  $wadvance ::
    HOAS.Contr
    -> Contract.ExtEnvP
    -> Contract.TEnv
    -> (# HOAS.Contr, Contract.FMap #)
  {- Arity: 3, Strictness: <L,1*C1(U)><L,C(C1(U))><L,C(U(1*U))>,
     Inline: [0],
     Unfolding: (\ w :: HOAS.Contr
                   w1 :: Contract.ExtEnvP
                   w2 :: Contract.TEnv ->
                 let {
                   ds :: (Contract.Contr, Contract.SMap)
                   = case Contract.redfun
                            (HOAS.fromHoas w)
                            (GHC.Types.[] @ (GHC.Base.Maybe Contract.Val))
                            w1
                            w2 of wild {
                       GHC.Base.Nothing
                       -> Data.Maybe.fromJust1 @ (Contract.Contr, Contract.SMap)
                       GHC.Base.Just x -> x }
                 } in
                 let {
                   c' :: Contract.Contr = case ds of wild { (,) c'1 t -> c'1 }
                 } in
                 (# \ @ (exp :: * -> *)
                      @ contr
                      $dContrHoas :: HOAS.ContrHoas exp contr ->
                    HOAS.fromClosed @ exp @ contr $dContrHoas c',
                    case ds of wild { (,) c'1 t -> t } #)) -}
c449da68b0f58e61caa9e8539347af49
  $wpoly_go1 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map (BaseTypes.RealObs, GHC.Types.Int) a
    -> [((BaseTypes.RealObs, GHC.Types.Int), a)]
    -> Data.Map.Base.Map (BaseTypes.RealObs, GHC.Types.Int) a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
1de8be5f75c49de596a258f84e7ad368
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map (BaseTypes.BoolObs, GHC.Types.Int) a
    -> [((BaseTypes.BoolObs, GHC.Types.Int), a)]
    -> Data.Map.Base.Map (BaseTypes.BoolObs, GHC.Types.Int) a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
0546511ad4dede1d0622ac0a418ce6e7
  $wpoly_go2 ::
    BaseTypes.BoolObs
    -> GHC.Types.Int
    -> Data.Map.Base.Map (BaseTypes.BoolObs, GHC.Types.Int) a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U(U)><S,1*U>,
     Inline: [0] -}
73e3809b8ecf33026e4d9deb04db2e33
  $wpoly_go3 ::
    BaseTypes.RealObs
    -> GHC.Types.Int
    -> Data.Map.Base.Map (BaseTypes.RealObs, GHC.Types.Int) a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U(U)><S,1*U>,
     Inline: [0] -}
e7268ffe9f11b54aba56981b8d211f2f
  advance ::
    HOAS.Contr
    -> Contract.ExtEnvP -> Contract.TEnv -> (HOAS.Contr, Contract.FMap)
  {- Arity: 3, Strictness: <L,1*C1(U)><L,C(C1(U))><L,C(U(1*U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: HOAS.Contr w1 :: Contract.ExtEnvP w2 :: Contract.TEnv ->
                 case EDSL.$wadvance w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
98500890884d901605314508bb49080a
  hasType :: Contract.TEnv -> HOAS.Contr -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,C(U(U))><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ tenv :: Contract.TEnv eta :: HOAS.Contr ->
                 case Contract.inferC
                        (GHC.Types.[] @ Contract.TiTy)
                        tenv
                        (HOAS.fromHoas eta) of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just ds -> GHC.Types.True }) -}
fa790f0e267718edab356219018659e8
  horizon :: HOAS.Contr -> Contract.TEnv -> GHC.Types.Int
  {- Arity: 2, Strictness: <C(S),1*C1(U)><L,C(U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ c :: HOAS.Contr tenv :: Contract.TEnv ->
                 case Contract.$whorizon (HOAS.fromHoas c) tenv of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
4b07a4e27dbc9de591556e3bff97c1cc
  mkExtEnvP ::
    [(BaseTypes.RealObs, GHC.Types.Int, GHC.Types.Double)]
    -> [(BaseTypes.BoolObs, GHC.Types.Int, GHC.Types.Bool)]
    -> Contract.ExtEnvP
  {- Arity: 2, Strictness: <L,1*U><L,1*U>,
     Unfolding: (\ rs :: [(BaseTypes.RealObs,
                           GHC.Types.Int,
                           GHC.Types.Double)]
                   bs :: [(BaseTypes.BoolObs, GHC.Types.Int, GHC.Types.Bool)] ->
                 let {
                   tabB :: Data.Map.Base.Map
                             (BaseTypes.BoolObs, GHC.Types.Int) Contract.Val
                   = EDSL.$sfromList
                       @ Contract.Val
                       (GHC.Base.map
                          @ (BaseTypes.BoolObs, GHC.Types.Int, GHC.Types.Bool)
                          @ ((BaseTypes.BoolObs, GHC.Types.Int), Contract.Val)
                          EDSL.mkExtEnvP2
                          bs)
                 } in
                 let {
                   tabR :: Data.Map.Base.Map
                             (BaseTypes.RealObs, GHC.Types.Int) Contract.Val
                   = EDSL.$sfromList2
                       @ Contract.Val
                       (GHC.Base.map
                          @ (BaseTypes.RealObs, GHC.Types.Int, GHC.Types.Double)
                          @ ((BaseTypes.RealObs, GHC.Types.Int), Contract.Val)
                          EDSL.mkExtEnvP1
                          rs)
                 } in
                 \ ds :: Contract.ObsLabel i :: GHC.Types.Int ->
                 case ds of wild {
                   Contract.LabR l -> EDSL.$wpoly_go3 @ Contract.Val l i tabR
                   Contract.LabB l -> EDSL.$wpoly_go2 @ Contract.Val l i tabB }) -}
7cd2836dc6074a3f181fce30733c0094
  mkExtEnvP1 ::
    (BaseTypes.RealObs, GHC.Types.Int, GHC.Types.Double)
    -> ((BaseTypes.RealObs, GHC.Types.Int), Contract.Val)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (BaseTypes.RealObs, GHC.Types.Int, GHC.Types.Double) ->
                 case ds of wild { (,,) l i r -> ((l, i), Contract.RVal r) }) -}
4a4a081bd2e29c25e0de0869351452ef
  mkExtEnvP2 ::
    (BaseTypes.BoolObs, GHC.Types.Int, GHC.Types.Bool)
    -> ((BaseTypes.BoolObs, GHC.Types.Int), Contract.Val)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (BaseTypes.BoolObs, GHC.Types.Int, GHC.Types.Bool) ->
                 case ds of wild { (,,) l i r -> ((l, i), Contract.BVal r) }) -}
6cda5674c839ce4e9592bec04d2a6667
  printContr :: HOAS.Contr -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                EDSL.printContr1
                  `cast`
                (<HOAS.Contr>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
4ea7da6451d75bbdbd4794526c5cc345
  printContr1 ::
    HOAS.Contr
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: HOAS.Contr
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (EDSL.showContr x)
                   GHC.Types.True
                   eta) -}
2bb606c78385600092ef810a0549f67d
  showContr :: HOAS.Contr -> GHC.Base.String
  {- Arity: 1, Strictness: <C(S),1*C1(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: HOAS.Contr ->
                 PrettyPrinting.ppContr
                   HOAS.$fShowContr2
                   (GHC.Types.[] @ GHC.Types.Int)
                   (HOAS.fromHoas x)) -}
fc7a615af7754857d6057129ddb7697c
  specialise ::
    HOAS.Contr -> Contract.TEnv -> Contract.ExtEnvP -> HOAS.Contr
  {- Arity: 4,
     Strictness: <L,1*C1(U)><L,C(U(U))><L,U><S(LLLLLLLLLLC(S)),1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U))>,
     Unfolding: InlineRule (4, True, False)
                (\ dk :: HOAS.Contr
                   dk1 :: Contract.TEnv
                   dk2 :: Contract.ExtEnvP
                   @ (exp :: * -> *)
                   @ contr
                   $dContrHoas :: HOAS.ContrHoas exp contr ->
                 HOAS.fromClosed
                   @ exp
                   @ contr
                   $dContrHoas
                   (Contract.specialise
                      ((dk @ HOAS.DB @ HOAS.CDB HOAS.$fContrHoasDBCDB)
                         `cast`
                       (HOAS.NTCo:CDB[0])
                         HOAS.$fShowContr2)
                      (GHC.Types.[] @ (GHC.Base.Maybe Contract.Val))
                      dk1
                      dk2)) -}
"SPEC/EDSL $fEq(,) @ BoolObs @ Int" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                              BaseTypes.BoolObs
                                                    $dEq1 :: GHC.Classes.Eq GHC.Types.Int
  GHC.Classes.$fEq(,) @ BaseTypes.BoolObs @ GHC.Types.Int $dEq $dEq1
  = EDSL.$s$fEq(,)
"SPEC/EDSL $fEq(,) @ RealObs @ Int" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                              BaseTypes.RealObs
                                                    $dEq1 :: GHC.Classes.Eq GHC.Types.Int
  GHC.Classes.$fEq(,) @ BaseTypes.RealObs @ GHC.Types.Int $dEq $dEq1
  = EDSL.$s$fEq(,)1
"SPEC/EDSL $fOrd(,) @ BoolObs @ Int" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                               (BaseTypes.BoolObs, GHC.Types.Int)
                                                     $dOrd :: GHC.Classes.Ord BaseTypes.BoolObs
                                                     $dOrd1 :: GHC.Classes.Ord GHC.Types.Int
  GHC.Classes.$fOrd(,) @ BaseTypes.BoolObs
                       @ GHC.Types.Int
                       $dEq
                       $dOrd
                       $dOrd1
  = EDSL.$s$fOrd(,)
"SPEC/EDSL $fOrd(,) @ RealObs @ Int" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                               (BaseTypes.RealObs, GHC.Types.Int)
                                                     $dOrd :: GHC.Classes.Ord BaseTypes.RealObs
                                                     $dOrd1 :: GHC.Classes.Ord GHC.Types.Int
  GHC.Classes.$fOrd(,) @ BaseTypes.RealObs
                       @ GHC.Types.Int
                       $dEq
                       $dOrd
                       $dOrd1
  = EDSL.$s$fOrd(,)2
"SPEC/EDSL fromList @ (BoolObs, Int) _" [ALWAYS] forall @ a
                                                        $dOrd :: GHC.Classes.Ord
                                                                   (BaseTypes.BoolObs,
                                                                    GHC.Types.Int)
  Data.Map.Base.fromList @ (BaseTypes.BoolObs, GHC.Types.Int)
                         @ a
                         $dOrd
  = EDSL.$sfromList @ a
"SPEC/EDSL fromList @ (RealObs, Int) _" [ALWAYS] forall @ a
                                                        $dOrd :: GHC.Classes.Ord
                                                                   (BaseTypes.RealObs,
                                                                    GHC.Types.Int)
  Data.Map.Base.fromList @ (BaseTypes.RealObs, GHC.Types.Int)
                         @ a
                         $dOrd
  = EDSL.$sfromList2 @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

